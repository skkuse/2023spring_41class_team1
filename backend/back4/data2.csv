,main_level,main_level_tag,sub_level,sub_level_tag,problem_idx,problem_comment,input_comment,output_comment,sample_data,chatGPT_output_code,hidden_test_case
0,17,조합론,3,팩토리얼,10872,"0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.",첫째 줄에 정수 N(0 ≤ N ≤ 12)이 주어진다.,첫째 줄에 N!을 출력한다.,"[['10', '3628800'], ['0', '1']]","#include <stdio.h>

int main() {
    int N, fact=1;
    scanf(""%d"", &N);
    for(int i=1; i<=N; i++) {
        fact *= i;
    }
    printf(""%d"", fact);
    return 0;
}","[[""0"", ""1""], [""1"", ""1""], [""2"", ""2""], [""3"", ""6""], [""4"", ""24""], [""5"", ""120""], [""6"", ""720""], [""7"", ""5040""], [""8"", ""40320""], [""10"", ""3628800""]]"
1,17,조합론,5,다리 놓기,1010,재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M),"입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.",각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.,"[['3\n2 2\n1 5\n13 29', '1\n5\n67863915']]","#include <stdio.h>

int main() {
    int T, i;
    scanf(""%d"", &T); // 테스트 케이스의 개수 입력
    for(i=0; i<T; i++) {
        int N, M, j;
        scanf(""%d %d"", &N, &M); // 각각의 테스트 케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 입력
        int dp[31][31] = {0}; // 다리를 지을 수 있는 경우의 수를 저장할 DP 배열 초기화
        for(j=1; j<=M; j++) dp[1][j] = j; // 초기값 설정
        for(j=2; j<=N; j++) {
            for(int k=j; k<=M; k++) {
                for(int l=j-1; l<k; l++) {
                    dp[j][k] += dp[j-1][l]; // 점화식 적용
                }
            }
        }
        printf(""%d\n"", dp[N][M]); // 각각의 테스트 케이스에 대해 다리를 지을 수 있는 경우의 수 출력
    }
    return 0;
}","[['1\n1 4\n', '4'], ['1\n2 7\n', '21'], ['1\n5 5\n', '1'], ['1\n0 1', '0'], ['1\n4 4', '1'], ['1\n5 5', '1'], ['1\n6 6', '1'], ['1\n10 10', '1'], ['1\n1 5\n', '5'], ['1\n2 3', '3']]"
2,19,스택,1,스택,10828,"정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.","첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.","출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.","[['14\npush 1\npush 2\ntop\nsize\nempty\npop\npop\npop\nsize\nempty\npop\npush 3\nempty\ntop', '2\n2\n0\n2\n1\n-1\n0\n1\n-1\n0\n3'], ['7\npop\ntop\npush 123\ntop\npop\ntop\npop', '-1\n-1\n123\n123\n-1\n-1']]","#include <stdio.h>
#include <string.h>

#define MAX_SIZE 10000

int stack[MAX_SIZE]; // 스택 선언
int top = -1; // 스택의 가장 위쪽 원소를 가리키는 인덱스. 초기값은 -1.

void push(int x) { // 스택에 x를 삽입하는 함수
    stack[++top] = x;
}

int pop() { // 스택에서 가장 위쪽 원소를 삭제하고 반환하는 함수
    if (top == -1) { // 스택이 비어있는 경우
        return -1;
    }
    else {
        return stack[top--];
    }
}

int size() { // 스택의 원소 개수를 반환하는 함수
    return top + 1;
}

int empty() { // 스택이 비어있으면 1, 아니면 0을 반환하는 함수
    if (top == -1) {
        return 1;
    }
    else {
        return 0;
    }
}

int top_func() { // 스택의 가장 위쪽 원소를 반환하는 함수
    if (top == -1) { // 스택이 비어있는 경우
        return -1;
    }
    else {
        return stack[top];
    }
}

int main() {
    int n;
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        char command[10];
        scanf(""%s"", command);
        if (strcmp(command, ""push"") == 0) { // push 명령인 경우
            int x;
            scanf(""%d"", &x);
            push(x);
        }
        else if (strcmp(command, ""pop"") == 0) { // pop 명령인 경우
            printf(""%d\n"", pop());
        }
        else if (strcmp(command, ""size"") == 0) { // size 명령인 경우
            printf(""%d\n"", size());
        }
        else if (strcmp(command, ""empty"") == 0) { // empty 명령인 경우
            printf(""%d\n"", empty());
        }
        else if (strcmp(command, ""top"") == 0) { // top 명령인 경우
            printf(""%d\n"", top_func());
        }
    }
    return 0;
}","[['4\npush 1\npush 2\ntop\npop', '2\n2'], ['4\npush 1\npush 2\ntop\nsize', '2\n2'], ['2\npush 1\nempty', '0'], ['1\npop', '-1'], ['1\nsize', '0'], ['1\ntop', '-1'], ['1\nempty', '1'], ['5\npush 1\npush 2\nsize\nempty\ntop', '2\n0\n2'], ['3\nempty\npush 100000\npop', '1\n100000'], ['6\npush 5\npush 8\ntop\nsize\nempty\npop', '8\n2\n0\n8']]"
3,21,재귀,1,팩토리얼 2,27433,"0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.",첫째 줄에 정수 N(0 ≤ N ≤ 20)이 주어진다.,첫째 줄에 N!을 출력한다.,"[['10', '3628800'], ['0', '1']]","#include <stdio.h>

int main() {
    int N;
    long long answer = 1; // N!의 결과를 저장할 변수

    scanf(""%d"", &N);

    for (int i = 2; i <= N; i++) {
        answer *= i; // i를 곱해서 N!을 계산한다
    }

    printf(""%lld\n"", answer);

    return 0;
}","[[""0"", ""1""], [""1"", ""1""], [""2"", ""2""], [""3"", ""6""], [""4"", ""24""], [""5"", ""120""], [""6"", ""720""], [""7"", ""5040""], [""8"", ""40320""], [""10"", ""3628800""]]"
4,23,동적 계획법 1,3,01타일,1904,"지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.","첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)",첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.,"[['4', '5']]","#include <stdio.h>

int dp[1000001];

int main() {
    int n;
    scanf(""%d"", &n);
    dp[1] = 1;
    dp[2] = 2;
    for(int i=3; i<=n; i++) {
        dp[i] = (dp[i-1] + dp[i-2]) % 15746;
    }
    printf(""%d"", dp[n]);
    return 0;
}","[['1', '1'], ['2', '2'], ['3', '3'], ['4', '5'], ['5', '8'], ['6', '13'], ['7', '21'], ['8', '34'], ['9', '55'], ['10', '89']]"
5,23,동적 계획법 1,5,연속합,1912,"n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.","첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.",첫째 줄에 답을 출력한다.,"[['10\n10 -4 3 1 5 6 -35 12 21 -1', '33'], ['10\n2 1 -4 3 4 -4 6 5 -5 1', '14'], ['5\n-1 -2 -3 -4 -5', '-1']]","#include <stdio.h>

int main() {
    int n, max_sum, current_sum, num;
    scanf(""%d"", &n);
    scanf(""%d"", &num);
    max_sum = current_sum = num;
    for (int i = 1; i < n; i++) {
        scanf(""%d"", &num);
        current_sum = (current_sum > 0) ? current_sum + num : num;
        if (current_sum > max_sum) {
            max_sum = current_sum;
        }
    }
    printf(""%d\n"", max_sum);
    return 0;
}","[['5\n-3 -2 -5 -7 -1', '-1'], ['6\n-4 3 -3 -2 1 -5', '3'], ['3\n-1 -2 -3', '-1'], ['3\n1 2 -10', '3'], ['3\n-1 2 -1', '2'], ['5\n1 -2 3 -4 5', '5'], ['1\n1', '1'], ['2\n1 -1', '1'], ['2\n-1 1', '1'], ['3\n1 2 -1', '3']]"
6,23,동적 계획법 1,7,정수 삼각형,1932,위 그림은 크기가 5인 정수 삼각형의 한 모습이다.,"첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.",첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.,"[['5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5', '30']]","#include <stdio.h>

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int triangle[n][n];

    // 삼각형 입력 받기
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            scanf(""%d"", &triangle[i][j]);
        }
    }

    // DP를 이용하여 합이 최대가 되는 경로의 합 구하기
    for (int i = n-2; i >= 0; i--) {
        for (int j = 0; j <= i; j++) {
            triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1]);
        }
    }

    printf(""%d\n"", triangle[0][0]);

    return 0;
}","[['1\n1', '1'], ['3\n1 1 1\n1 1 10\n1 1 1', '12'], ['4\n5 1 1 1\n1 1 1 1\n1 1 1 1\n1 1 1 1', '8'], ['3\n-1 -10 -1\n-10 -1 -10\n-1 -10 -1', '-3'], ['2\n1\n2 3', '4'], ['3\n1\n2 3\n4 5 6', '10'], ['4\n3\n1 1\n1 1 1\n1 1 1 1', '6'], ['5\n6\n1 1\n2 1 2\n3 1 3 1\n2 1 2 1 2\n4 1 4 1 4 1', '14'], ['5\n-1\n-1 -1\n-1 -1 -1\n-1 -1 -1 -1\n-1 -1 -1 -1 -1', '-5'], ['2\n5\n8 6', '13']]"
7,23,동적 계획법 1,11,포도주 시식,2156,"효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.","첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.",첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.,"[['6\n6\n10\n13\n9\n8\n1', '33']]","#include <stdio.h>

int max(int a, int b) {
    return a > b ? a : b; // a와 b 중 더 큰 값을 반환하는 함수
}

int main() {
    int n, i;
    int grape[10001] = {0}; // 포도주의 양을 저장하는 배열
    int dp[10001] = {0}; // 다이나믹 프로그래밍을 위한 배열

    scanf(""%d"", &n);

    for (i = 1; i <= n; i++) {
        scanf(""%d"", &grape[i]);
    }

    dp[1] = grape[1]; // 첫 번째 잔은 무조건 마시므로 dp[1]에 초기값 할당
    dp[2] = grape[1] + grape[2]; // 두 번째 잔도 마시는 것이 최대이므로 초기값 할당

    for (i = 3; i <= n; i++) {
        // 경우의 수 3가지 중 가장 큰 값으로 dp[i]를 갱신
        dp[i] = max(max(dp[i-1], dp[i-2]+grape[i]), dp[i-3]+grape[i-1]+grape[i]);
    }

    printf(""%d\n"", dp[n]);

    return 0;
}","[['1\n1', '1'], ['2\n1\n2', '3'], ['3\n1\n1\n1', '2'], ['5\n1\n2\n3\n4\n5', '12'], ['6\n6\n10\n13\n9\n8\n1', '33'], ['7\n5\n5\n5\n5\n5\n5\n5', '25'], ['1\n100', '100'], ['2\n50\n100', '150'], ['3\n25\n50\n75', '125'], ['5\n5\n10\n15\n20\n25', '60']]"
8,23,동적 계획법 1,13,가장 긴 바이토닉 부분 수열,11054,"수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.","첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)",첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.,"[['10\n1 5 2 1 4 3 4 5 2 1', '7']]","#include <stdio.h>

int main() {
    int n, i, j;
    int a[1001];
    int inc[1001] = {0}; // 증가 수열 길이 저장 배열
    int dec[1001] = {0}; // 감소 수열 길이 저장 배열
    int max = 0;

    scanf(""%d"", &n);
    for(i=0; i<n; i++) {
        scanf(""%d"", &a[i]);
    }

    // 증가 수열 길이 구하기
    for(i=0; i<n; i++) {
        for(j=0; j<i; j++) {
            if(a[i] > a[j] && inc[i] < inc[j]) {
                inc[i] = inc[j];
            }
        }
        inc[i]++;
    }

    // 감소 수열 길이 구하기
    for(i=n-1; i>=0; i--) {
        for(j=n-1; j>i; j--) {
            if(a[i] > a[j] && dec[i] < dec[j]) {
                dec[i] = dec[j];
            }
        }
        dec[i]++;
    }

    // 가장 긴 바이토닉 수열 길이 구하기
    for(i=0; i<n; i++) {
        if(max < inc[i] + dec[i] - 1) {
            max = inc[i] + dec[i] - 1;
        }
    }

    printf(""%d"", max);

    return 0;
}","[['5\n1 2 3 4 5', '5'], ['10\n1 2 3 4 5 4 3 2 1 2', '9'], ['5\n5 1 3 2 4', '3'], ['3\n1 2 1', '3'], ['10\n1 5 2 1 4 3 4 5 2 1', '7'], ['4\n1 2 2 1', '3'], ['3\n3 2 1', '3'], ['1\n1', '1'], ['2\n1 1', '1'], ['10\n1 2 3 4 5 6 7 8 9 10', '10']]"
9,23,동적 계획법 1,15,LCS,9251,"LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.","첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.",첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.,"[['ACAYKP\nCAPCAK', '4']]","#include <stdio.h>
#include <string.h>

int lcs[1001][1001];

int max(int a, int b) {
    return a > b ? a : b;
}

int main() {
    char str1[1001], str2[1001];
    scanf(""%s %s"", str1, str2);

    int len1 = strlen(str1);
    int len2 = strlen(str2);

    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (str1[i - 1] == str2[j - 1]) {
                lcs[i][j] = lcs[i - 1][j - 1] + 1;
            } else {
                lcs[i][j] = max(lcs[i][j - 1], lcs[i - 1][j]);
            }
        }
    }

    printf(""%d\n"", lcs[len1][len2]);

    return 0;
}","[['ABCDGH\nAEDFHR', '3'], ['AGGTAB\nGXTXAYB', '4'], ['AAAAAA\nBBBBBB', '0'], ['ABC\nDEF', '0'], ['AAAAAA\nA', '1'], ['AAABBB\nCCCDDD', '0'], ['CCCCC\nCCCCCCC', '5'], ['ABCD\nEFGH', '0'], ['ABCD\nDCBA', '1'], ['ABCDE\nEDCBA', '1']]"
10,25,그리디 알고리즘,1,동전 0,11047,"준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.","첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)",첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.,"[['10 4200\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n50000', '6'], ['10 4790\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n50000', '12']]","#include <stdio.h>

int main(){
    int n, k, i;
    int coin[10];
    int count = 0;
    scanf(""%d %d"", &n, &k);
    for(i=0;i<n;i++){
        scanf(""%d"", &coin[i]);
    }
    for(i=n-1;i>=0;i--){
        count += k/coin[i];
        k %= coin[i];
    }
    printf(""%d"", count);
    return 0;
}","[['1 100\n50', '2'], ['5 10\n1\n2\n3\n4\n5', '2'], ['10 4200\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n50000', '6'], ['10 4790\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n50000', '12'], ['7 50\n5\n7\n13\n18\n21\n25\n30', '2'], ['3 20\n1\n2\n5', '4'], ['5 100\n10\n3\n5\n20\n50', '2'], ['6 500\n1\n2\n3\n4\n5\n10', '50'], ['7 10000\n10\n50\n100\n500\n1000\n5000\n10000', '1'], ['1 1000\n1', '1000']]"
11,25,그리디 알고리즘,3,ATM,11399,"인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.","첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)",첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.,"[['5\n3 1 4 3 2', '32']]","#include <stdio.h>

void quickSort(int arr[], int left, int right); // 퀵 정렬 함수 선언

int main() {
    int n, sum = 0;
    scanf(""%d"", &n); // 사람 수 입력
    int p[n]; // 사람별 인출 시간을 저장하는 배열
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &p[i]); // 각 사람의 인출 시간 입력
    }
    quickSort(p, 0, n-1); // 퀵 정렬로 오름차순 정렬
    for (int i = 0; i < n; i++) {
        sum += p[i]*(n-i); // 각 사람의 인출 시간과 대기 시간을 곱해서 합산
    }
    printf(""%d"", sum); // 결과 출력
    return 0;
}

void quickSort(int arr[], int left, int right) { // 퀵 정렬 함수 구현
    int i = left, j = right;
    int pivot = arr[(left+right)/2];
    while (i <= j) {
        while (arr[i] < pivot) {
            i++;
        }
        while (arr[j] > pivot) {
            j--;
        }
        if (i <= j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
    if (left < j) {
        quickSort(arr, left, j);
    }
    if (i < right) {
        quickSort(arr, i, right);
    }
}","[['1\n1000', '1000'], ['3\n1 2 3', '10'], ['4\n4 3 2 1', '20'], ['5\n5 4 3 2 1', '35'], ['7\n7 6 5 4 3 2 1', '84'], ['9\n9 8 7 6 5 4 3 2 1', '165'], ['1\n1', '1'], ['6\n6 5 4 3 2 1', '56'], ['10\n10 9 8 7 6 5 4 3 2 1', '220'], ['5\n5 1 4 3 2', '35']]"
12,27,이분 탐색,3,랜선 자르기,1654,집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.,"첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다.",첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.,"[['4 11\n802\n743\n457\n539', '200']]","#include <stdio.h>
#define ll long long // 64비트 정수형을 위해 long long으로 정의

int k, n;
ll lan[10001];

int main() {
    scanf(""%d %d"", &k, &n);
    for (int i = 0; i < k; i++) {
        scanf(""%lld"", &lan[i]); // lan은 long long형 배열
    }

    ll left = 1, right = (1LL << 31) - 1; // 이분 탐색을 위한 left, right 설정
    while (left <= right) { // 이분 탐색 시작
        ll mid = (left + right) / 2;
        int cnt = 0;
        for (int i = 0; i < k; i++) {
            cnt += lan[i] / mid; // mid 길이로 만들 수 있는 랜선 개수 누적
        }
        if (cnt >= n) { // n개 이상 만들 수 있는 경우
            left = mid + 1; // mid를 키워서 최대 길이를 구하기 위해 left 업데이트
        }
        else { // n개 이상 만들 수 없는 경우
            right = mid - 1; // mid를 줄여서 최대 길이를 구하기 위해 right 업데이트
        }
    }

    printf(""%lld"", right); // 최대 길이인 right 출력
    return 0;
}","[['1 1\n100', '100'], ['1 10\n100', '10'], ['2 2\n3\n7', '3'], ['5 7\n1\n2\n3\n5\n6', '2'], ['1 1\n1000', '1000'], ['1 1\n1', '1'], ['3 3\n1\n2\n3', '1'], ['5 5\n1\n1\n1\n1\n1', '1'], ['2 2\n10\n10', '10'], ['1 1\n1000000000', '1000000000']]"
13,27,이분 탐색,5,공유기 설치,2110,"도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.","첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.",첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.,"[['5 3\n1\n2\n8\n4\n9', '3']]","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int cmp(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

bool is_possible(int dist, int* house, int n, int c) {
    int cnt = 1;
    int prev = house[0];
    for (int i = 1; i < n; i++) {
        if (house[i] - prev >= dist) {
            cnt++;
            prev = house[i];
        }
    }
    return cnt >= c;
}

int main() {
    int n, c;
    scanf(""%d %d"", &n, &c);
    int house[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &house[i]);
    }
    qsort(house, n, sizeof(int), cmp);
    int left = 1, right = house[n-1] - house[0], ans = 0;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (is_possible(mid, house, n, c)) {
            ans = mid;
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    printf(""%d"", ans);
    return 0;
}","[['2 2\n1\n2', '1'], ['5 3\n1\n3\n8\n10\n13', '5'], ['2 2\n100\n200', '100'], ['2 2\n0\n10000', '10000'], ['3 2\n3\n6\n9', '6'], ['5 3\n1\n2\n8\n4\n9', '3'], ['2 2\n0\n1', '1'], ['7 3\n1\n2\n3\n5\n6\n9\n10', '4'], ['2 2\n1\n100', '99'], ['3 2\n1\n3\n10', '9']]"
14,29,동적 계획법 2,5,동전 1,2293,"n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.","첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.",첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.,"[['3 10\n1\n2\n5', '10']]","#include <stdio.h>
#define MAX_N 100
#define MAX_K 10000

int n, k;
int coin[MAX_N+1];
int dp[MAX_K+1];

int main() {
    scanf(""%d %d"", &n, &k);
    for (int i = 1; i <= n; i++) {
        scanf(""%d"", &coin[i]);
    }

    dp[0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = coin[i]; j <= k; j++) {
            dp[j] += dp[j - coin[i]];
        }
    }

    printf(""%d"", dp[k]);

    return 0;
}","[['1 10000\n1', '1'], ['3 50\n20\n30\n40', '1'], ['1 1\n1', '1'], ['2 10\n3\n5', '1'], ['4 5\n1\n2\n3\n4', '6'], ['2 50\n5\n10', '6'], ['2 10000\n1\n100', '101'], ['1 5\n1', '1'], ['2 3\n1\n2', '2'], ['1 3\n3', '1']]"
15,31,그래프와 순회,5,바이러스,2606,신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.,첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.,"1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.","[['7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7', '4']]","#include <stdio.h>

#define MAX_N 100 // 최대 컴퓨터 수
#define MAX_M 10000 // 최대 연결 수

int graph[MAX_N+1][MAX_N+1]; // 그래프
int visited[MAX_N+1]; // 방문 여부
int n, m; // 컴퓨터 수, 연결 수

void dfs(int v) { // 깊이 우선 탐색
    visited[v] = 1; // 현재 노드 방문 처리
    for (int i = 1; i <= n; i++) { // 모든 노드에 대해
        if (graph[v][i] && !visited[i]) { // 연결되어 있고, 방문하지 않은 노드이면
            dfs(i); // 해당 노드에서 dfs 탐색 계속
        }
    }
}

int main() {
    scanf(""%d %d"", &n, &m);
    for (int i = 0; i < m; i++) {
        int a, b;
        scanf(""%d %d"", &a, &b);
        graph[a][b] = 1; // 양방향 연결 처리
        graph[b][a] = 1;
    }
    dfs(1); // 1번 노드에서부터 dfs 탐색 시작
    int count = 0;
    for (int i = 1; i <= n; i++) { // 방문한 노드 수 세기
        if (visited[i]) count++;
    }
    printf(""%d\n"", count-1); // 1번 노드는 제외하고 출력
    return 0;
}","[['5\n4\n1 2\n2 3\n2 4\n4 5', '4'], ['7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7', '4'], ['10\n4\n1 2\n3 4\n5 6\n7 8', '1'], ['6\n5\n1 2\n2 3\n1 5\n5 2\n5 6', '4'], ['2\n1\n1 2', '1'], ['4\n2\n1 4\n3 4', '2'], ['10\n9\n1 2\n1 4\n2 3\n2 5\n3 6\n4 6\n5 6\n6 7\n6 8', '7'], ['8\n5\n1 2\n2 3\n4 5\n5 6\n6 7', '2'], ['4\n2\n1 2\n3 4', '1'], ['3\n2\n1 2\n2 3', '2']]"
16,31,그래프와 순회,9,미로 탐색,2178,N×M크기의 배열로 표현되는 미로가 있다.,"첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.",첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.,"[['4 6\n101111\n101010\n101011\n111011', '15'], ['4 6\n110110\n110110\n111111\n111101', '9'], ['2 25\n1011101110111011101110111\n1110111011101110111011101', '38'], ['7 7\n1011111\n1110001\n1000001\n1000001\n1000001\n1000001\n1111111', '13']]","#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, m;
    scanf(""%d %d"", &n, &m);

    // 미로를 저장할 2차원 배열 생성
    int arr[n][m];

    // 미로 입력 받기
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf(""%1d"", &arr[i][j]); // 한 자리씩 입력 받음
        }
    }

    // BFS 알고리즘을 위한 큐 생성
    int queue[n * m][2];
    int front = 0, rear = 0;

    // 시작점 (0, 0)을 큐에 삽입
    queue[rear][0] = 0; 
    queue[rear][1] = 0;
    rear++;

    // 이동할 네 방향 (상, 하, 좌, 우)
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    // BFS 알고리즘 실행
    while (front != rear) { // 큐가 비어있지 않은 동안
        int x = queue[front][0];
        int y = queue[front][1];
        front++;

        for (int i = 0; i < 4; i++) { // 네 방향 탐색
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m && arr[nx][ny] == 1) { // 범위를 벗어나지 않고, 이동 가능한 경우
                arr[nx][ny] = arr[x][y] + 1; // 최단 거리 갱신
                queue[rear][0] = nx;
                queue[rear][1] = ny;
                rear++;
            }
        }
    }

    // 도착점의 최단 거리 출력
    printf(""%d"", arr[n-1][m-1]);

    return 0;
}","[['5 5\n11111\n00101\n11101\n10001\n11111', '9'], ['4 4\n1000\n1110\n1000\n1111', '7'], ['6 6\n101101\n101101\n111111\n101001\n101001\n111111', '11'], ['3 3\n110\n100\n111', '5'], ['5 5\n10111\n10101\n10111\n10001\n11111', '9'], ['4 6\n101111\n101010\n101011\n111011', '15'], ['6 6\n111111\n111111\n111111\n111111\n111111\n111111', '11'], ['5 5\n11111\n11101\n11011\n10111\n11111', '9'], ['2 10\n1010101010\n1111111111', '11'], ['3 3\n101\n101\n111', '5']]"
17,33,투 포인터,3,부분합,1806,"10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.","첫째 줄에 N (10 ≤ N < 100,000)과 S (0 < S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.",첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.,"[['10 15\n5 1 3 5 10 7 4 9 2 8', '2']]","#include <stdio.h>

int n, s;
int arr[100000];

int main() {
    scanf(""%d %d"", &n, &s);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int start = 0, end = 0;
    int sum = arr[0];
    int ans = 100001;

    while (start <= end && end < n) {
        if (sum < s) {
            end++;
            sum += arr[end];
        } else if (sum >= s) {
            if (end - start + 1 < ans) {
                ans = end - start + 1;
            }
            sum -= arr[start];
            start++;
        }
    }

    if (ans == 100001) {
        printf(""0\n"");
    } else {
        printf(""%d\n"", ans);
    }

    return 0;
}","[['10 15\n5 1 3 5 10 7 4 9 2 8', '2'], ['20 50\n20 1 3 5 10 7 4 9 2 8 4 23 18 13 11 6 9 14 29 30 21', '2'], ['10 1\n1 1 1 1 1 1 1 1 1 1', '1'], ['10 100\n10 20 30 40 50 60 70 80 90 100', '1'], ['10 100\n100 100 100 100 100 100 100 100 100 100', '1'], ['5 1\n1 1 1 1 1', '1'], ['10 10\n20 20 20 1 1 1 1 1 1 1', '1'], ['6 50\n10 20 30 40 50 60', '1'], ['5 50\n10 20 30 40 50', '1'], ['6 80\n5 15 25 35 45 55', '2']]"
18,18,심화 2,1,약수,1037,"양수 A가 N의 진짜 약수가 되려면, N이 A의 배수이고, A가 1과 N이 아니어야 한다. 어떤 수 N의 진짜 약수가 모두 주어질 때, N을 구하는 프로그램을 작성하시오.","첫째 줄에 N의 진짜 약수의 개수가 주어진다. 이 개수는 50보다 작거나 같은 자연수이다. 둘째 줄에는 N의 진짜 약수가 주어진다. 1,000,000보다 작거나 같고, 2보다 크거나 같은 자연수이고, 중복되지 않는다.",첫째 줄에 N을 출력한다. N은 항상 32비트 부호있는 정수로 표현할 수 있다.,"[['2\n4 2', '8'], ['1\n2', '4'], ['6\n3 4 2 12 6 8', '24'], ['14\n14 26456 2 28 13228 3307 7 23149 8 6614 46298 56 4 92596', '185192']]","#include<stdio.h>

int main(){
    int n;
    scanf(""%d"", &n);
    int factor[n];
    for(int i=0;i<n;i++){
        scanf(""%d"", &factor[i]);
    }
    int max=factor[0], min=factor[0];
    for(int i=1;i<n;i++){
        if(factor[i]>max) max=factor[i];
        if(factor[i]<min) min=factor[i];
    }
    printf(""%d"", max*min);
    return 0;
}","[['2\n11 121', '1331'], ['8\n7 14 21 28 35 42 49 56', '392'], ['3\n40 20 5', '200'], ['2\n5 25', '125'], ['2\n3 4', '12'], ['2\n1000 2', '2000'], ['6\n2 3 7 14 21 42', '84'], ['2\n1 1000000', '1000000'], ['4\n3 6 9 18', '54'], ['2\n4 2', '8']]"
19,22,백트래킹,5,N-Queen,9663,N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.,첫째 줄에 N이 주어진다. (1 ≤ N < 15),첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.,"[['8', '92']]","#include <stdio.h>
#include <stdbool.h>

int n; // 체스판 크기
int count; // 퀸을 놓는 경우의 수
int col[15]; // 각 행에 놓인 퀸의 열 번호 저장

// 퀸을 놓을 수 있는지 검사하는 함수
bool check(int row, int col_num) {
    for (int i = 0; i < row; i++) {
        if (col[i] == col_num // 같은 열에 놓여 있는 경우
            || row - i == col_num - col[i] // 대각선 상에 놓여 있는 경우
            || row - i == col[i] - col_num) // 대각선 상에 놓여 있는 경우
            return false; // 놓을 수 없음
    }
    return true; // 놓을 수 있음
}

// 퀸을 놓는 함수
void queen(int row) {
    if (row == n) {
        count++; // 경우의 수 증가
        return;
    }
    for (int i = 0; i < n; i++) {
        if (check(row, i)) { // 퀸을 놓을 수 있는 경우
            col[row] = i; // 해당 행에 퀸을 놓음
            queen(row + 1); // 다음 행에 퀸을 놓음
        }
    }
}

int main() {
    scanf(""%d"", &n);
    queen(0); // 0번째 행부터 시작
    printf(""%d"", count);
    return 0;
}","[['1', '1'], ['2', '0'], ['3', '0'], ['4', '2'], ['5', '10'], ['6', '4'], ['7', '40'], ['8', '92'], ['9', '352'], ['10', '724']]"
20,22,백트래킹,7,연산자 끼워넣기,14888,"N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.","첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다. ","첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.","[['2\n5 6\n0 0 1 0', '30\n30'], ['3\n3 4 5\n1 0 1 0', '35\n17'], ['6\n1 2 3 4 5 6\n2 1 1 1', '54\n-24']]","#include <stdio.h>
#include <limits.h> // INT_MAX, INT_MIN 사용을 위한 헤더파일
#define MAX_N 11 // 문제에서 N의 최댓값이 11임을 알 수 있음
#define MAX_OP 4 // 연산자의 개수(덧셈, 뺄셈, 곱셈, 나눗셈)가 4임을 알 수 있음

int N, op[MAX_OP]; // N: 수의 개수, op: 연산자의 개수
int A[MAX_N]; // 주어진 수
int max_res = INT_MIN, min_res = INT_MAX; // 최댓값과 최솟값을 저장하기 위한 변수

void dfs(int idx, int res) { // idx: 현재까지 끼워넣은 연산자의 개수, res: 현재까지 계산한 결과
    if (idx == N - 1) { // 모든 연산자를 다 끼워넣은 경우
        if (res > max_res) max_res = res; // 최댓값 업데이트
        if (res < min_res) min_res = res; // 최솟값 업데이트
        return; // 현재까지 계산한 결과 반환
    }
    for (int i = 0; i < MAX_OP; i++) { // 연산자 종류에 대해 모두 시도해보기
        if (op[i] > 0) { // 해당 연산자를 아직 다 사용하지 않은 경우
            op[i]--; // 해당 연산자 사용 표시(-1)
            if (i == 0) dfs(idx + 1, res + A[idx + 1]); // 덧셈
            else if (i == 1) dfs(idx + 1, res - A[idx + 1]); // 뺄셈
            else if (i == 2) dfs(idx + 1, res * A[idx + 1]); // 곱셈
            else if (i == 3) dfs(idx + 1, res / A[idx + 1]); // 나눗셈
            op[i]++; // 해당 연산자 사용 표시(+1)
        }
    }
}

int main() {
    scanf(""%d"", &N);
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &A[i]);
    }
    for (int i = 0; i < MAX_OP; i++) {
        scanf(""%d"", &op[i]);
    }
    dfs(0, A[0]); // 처음에는 첫 번째 수를 결과에 넣어주기
    printf(""%d\n%d\n"", max_res, min_res); // 최댓값과 최솟값 출력
    return 0;
}","[['2\n5 6\n0 0 1 0', '30\n30'], ['3\n3 4 5\n1 0 1 0', '35\n17'], ['6\n1 2 3 4 5 6\n2 1 1 1', '54\n-24'], ['2\n1 2\n1 0 0 0', '3\n3'], ['2\n10 20\n0 0 1 0', '200\n200'], ['2\n1 1\n0 0 1 0', '1\n1'], ['2\n8 9\n0 1 0 0', '-1\n-1'], ['3\n1 2 3\n0 0 1 1', '0\n0'], ['4\n4 6 8 10\n0 1 0 1', '-2147483648\n2147483647'], ['5\n1 2 3 4 5\n0 0 1 1', '-2147483648\n2147483647']]"
21,26,분할 정복,1,색종이 만들기,2630,"아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.","첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.","첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.","[['8\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 1 1\n0 0 0 0 1 1 0 0\n0 0 0 0 1 1 0 0\n1 0 0 0 1 1 1 1\n0 1 0 0 1 1 1 1\n0 0 1 1 1 1 1 1\n0 0 1 1 1 1 1 1', '9\n7']]","#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int paper[129][129] = { 0 };
int white_cnt = 0;
int blue_cnt = 0;

void count_paper(int x, int y, int size) {
    int start = paper[x][y];
    if (size == 1) {
        if (start == 0) white_cnt++;
        else blue_cnt++;
        return;
    }
    for (int i = x; i < x + size; i++) {
        for (int j = y; j < y + size; j++) {
            if (paper[i][j] != start) {
                size /= 2;
                count_paper(x, y, size);
                count_paper(x, y + size, size);
                count_paper(x + size, y, size);
                count_paper(x + size, y + size, size);
                return;
            }
        }
    }
    if (start == 0) white_cnt++;
    else blue_cnt++;
}

int main() {
    int n;
    scanf(""%d"", &n);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &paper[i][j]);
        }
    }

    count_paper(0, 0, n);

    printf(""%d\n%d"", white_cnt, blue_cnt);

    return 0;
}","[['4\n1 0 1 0\n0 1 0 1\n1 0 1 0\n0 1 0 1', '8\n8'], ['2\n1 0\n0 1', '2\n2'], ['2\n0 0\n0 0', '1\n0'], ['4\n0 0 1 1\n0 0 1 1\n1 1 0 0\n1 1 0 0', '2\n2'], ['8\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 1 1\n0 0 0 0 1 1 0 0\n0 0 0 0 1 1 0 0\n1 0 0 0 1 1 1 1\n0 1 0 0 1 1 1 1\n0 0 1 1 1 1 1 1\n0 0 1 1 1 1 1 1', '9\n7'], ['4\n0 1 1 0\n0 0 0 0\n1 1 0 1\n1 1 1 1', '7\n6'], ['4\n0 0 1 1\n0 0 1 1\n0 0 0 0\n0 0 0 0', '3\n1'], ['8\n1 1 0 0 0 0 1 1\n1 1 0 0 0 0 1 1\n0 0 0 0 1 1 0 0\n0 0 0 0 1 1 0 0\n1 0 0 0 1 1 1 1\n0 1 0 0 1 1 1 1\n0 0 1 0 1 1 1 1\n0 0 0 1 1 1 1 0', '12\n13'], ['8\n1 1 0 0 1 1 0 0\n1 1 0 0 1 1 0 0\n0 0 0 0 1 1 0 0\n0 0 0 0 1 1 0 0\n1 0 0 0 1 1 1 1\n0 1 0 0 1 1 1 1\n0 0 1 1 1 1 1 1\n0 0 1 1 1 1 1 1', '9\n7'], ['8\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1', '0\n1']]"
22,30,스택 2,1,문자열 폭발,9935,"상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.","첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.",첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.,"[['mirkovC4nizCC44\nC4', 'mirkovniz'], ['12ab112ab2ab\n12ab', 'FRULA']]","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char str[1000001], bomb[37];
    int len, bomb_len, i, top = 0;
    scanf(""%s%s"", str, bomb);
    len = strlen(str);
    bomb_len = strlen(bomb);
    char stack[len];
    for (i = 0; i < len; i++) {
        stack[top++] = str[i];
        if (top >= bomb_len && stack[top-1] == bomb[bomb_len-1]) {
            int flag = 1;
            for (int j = 0; j < bomb_len; j++) {
                if (bomb[bomb_len-j-1] != stack[top-j-1]) {
                    flag = 0;
                    break;
                }
            }
            if (flag == 1) top -= bomb_len;
        }
    }
    if (top == 0) printf(""FRULA"");
    else {
        for (i = 0; i < top; i++) printf(""%c"", stack[i]);
    }
    return 0;
}","[['abcd\n', 'abcd'], ['abcd\nb', 'acd'], ['xyz\nx', 'yz'], ['abbc\nbb', 'ac'], ['abcdef\nghij', 'abcdef'], ['aaaaaab\nb', 'aaaaaa'], ['bigapplewilldrop\nwill', 'bigappledrop'], ['abcd\nabc', 'd'], ['12345\n45', '123'], ['a\naa', 'a']]"
23,37,최소 신장 트리,1,상근이의 여행,9372,상근이는 겨울방학을 맞아 N개국을 여행하면서 자아를 찾기로 마음먹었다. ,"첫 번째 줄에는 테스트 케이스의 수 T(T ≤ 100)가 주어지고,",테스트 케이스마다 한 줄을 출력한다.,"[['2\n3 3\n1 2\n2 3\n1 3\n5 4\n2 1\n2 3\n4 3\n4 5', '2\n4']]","#include <stdio.h>

int main() {
    int T;
    scanf(""%d"", &T);

    for (int i = 0; i < T; i++) {
        int N, M;
        scanf(""%d %d"", &N, &M);

        for (int j = 0; j < M; j++) {
            int a, b;
            scanf(""%d %d"", &a, &b);
        }

        printf(""%d\n"", N - 1);
    }

    return 0;
}","[['1\n1 0\n', '0'], ['1\n5 4\n1 2\n1 3\n1 4\n1 5', '4'], ['1\n2 1\n1 2', '1'], ['1\n6 5\n1 2\n2 3\n3 4\n4 5\n5 6', '5'], ['1\n2 2\n1 2\n2 1', '1'], ['3\n3 2\n1 2\n2 3\n1 3\n2 1\n3 1\n1 1\n1 3\n3 1\n3 3', '2\n0\n0'], ['2\n5 4\n1 2\n1 3\n2 3\n2 4\n3 4\n1 2\n3 4\n7 3\n1 2\n3 2\n4 1\n5 1\n6 1\n7 2\n6 3', '4\n2'], ['2\n1 1\n1 1\n5 4\n1 2\n3 4\n2 3\n4 5', '0\n4'], ['1\n6 7\n1 2\n1 3\n2 3\n2 4\n3 4\n3 5\n4 5', '5'], ['1\n4 3\n1 2\n2 3\n3 1', '3']]"
24,31,그래프와 순회,5,바이러스,2606,신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.,첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.,"1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.","[['7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7', '4']]","#include <stdio.h>

int N, M, cnt;
int map[101][101]; // 인접 행렬
int visit[101]; // 방문 여부 저장을 위한 배열

void dfs(int start) { // dfs 함수 정의
    visit[start] = 1; // 현재 노드 방문 여부 체크
    cnt++; // 걸리는 컴퓨터 수 증가
    for (int i = 1; i <= N; i++) {
        if (visit[i] == 0 && map[start][i] == 1) { // 아직 방문하지 않았고 현재 노드와 이어진 노드인 경우
            dfs(i); // 이어진 노드로 이동
        }
    }
}

int main() {
    scanf(""%d %d"", &N, &M);
    for (int i = 0; i < M; i++) {
        int from, to;
        scanf(""%d %d"", &from, &to);
        map[from][to] = map[to][from] = 1; // 양방향 간선이므로 map에 1로 저장
    }

    dfs(1); // 1번 노드부터 dfs 탐색
    printf(""%d\n"", cnt - 1); // 1번 노드는 제외하고 출력
    return 0;
}","[['7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7', '4'], ['6\n4\n3 1\n3 4\n4 2\n4 5', '4'], ['9\n7\n1 2\n2 3\n3 1\n3 4\n4 5\n5 6\n6 4\n', '5'], ['5\n4\n1 2\n2 3\n2 4\n4 5', '4'], ['10\n4\n1 2\n3 4\n5 6\n7 8', '1'], ['6\n5\n1 2\n2 3\n1 5\n5 2\n5 6', '4'], ['2\n1\n1 2', '1'], ['4\n2\n1 4\n3 4', '2'], ['10\n9\n1 2\n1 4\n2 3\n2 5\n3 6\n4 6\n5 6\n6 7\n6 8', '7'], ['4\n1\n2 3', '0']]"
25,30,스택 2,1,문자열 폭발,9935,"상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.","첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.",첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.,"[['mirkovC4nizCC44\nC4', 'mirkovniz'], ['12ab112ab2ab\n12ab', 'FRULA']]","#include <stdio.h>
#include <string.h>

char s[1000001]; // 문자열
char bomb[37]; // 폭발 문자열
char ans[1000001]; // 정답으로 출력할 문자열

int main() {
    scanf(""%s %s"", s, bomb); // 문자열과 폭발 문자열 입력 받기
    int len = strlen(bomb); // 폭발 문자열 길이
    int pos = 0; // ans 배열 인덱스를 나타내는 변수
    int slen = strlen(s); // 문자열 길이
    for (int i = 0; i < slen; i++) {
        ans[pos++] = s[i]; // ans 배열에 문자 추가
        if (ans[pos-1] == bomb[len-1] && pos >= len) { // 폭발 문자열의 마지막 문자가 추가되고, 그 이상일 경우 폭발 문자열 여부 확인
            int check = 1;
            for (int j = 0; j < len; j++) { // 폭발 문자열과 일치하는지 확인
                if (ans[pos-len+j] != bomb[j]) {
                    check = 0;
                    break;
                }
            }
            if (check) pos -= len; // 폭발 문자열일 경우 ans 배열에서 지우기
        }
    }
    if (pos == 0) printf(""FRULA""); // ans 배열이 비었을 경우
    else { // ans 배열이 비어있지 않은 경우 문자열 출력
        for (int i = 0; i < pos; i++) {
            printf(""%c"", ans[i]);
        }
    }
    return 0;
}","[['mirkovC4nizCC44\nC4', 'mirkovniz'], ['12ab112ab2ab\n12ab', 'FRULA'], ['abcdefg\n', 'abcdefg'], ['aaabbb\naaa', 'bbb'], ['7777QWE7777\n7', 'QWE'], ['AAABBBCCC\nAAA', 'BBBCCC'], ['123659321\n123', '659321'], ['abcdefg\nxyz', 'abcdefg'], ['abcdefghijk\na', 'bcdefghijk'], ['CCCCDDDDDD\nCCCC', 'DDDDDD']]"
26,29,동적 계획법 2,2,행렬 곱셈 순서,11049,크기가 N×M인 행렬 A와 M×K인 B를 곱할 때 필요한 곱셈 연산의 수는 총 N×M×K번이다. 행렬 N개를 곱하는데 필요한 곱셈 연산의 수는 행렬을 곱하는 순서에 따라 달라지게 된다.,첫째 줄에 행렬의 개수 N(1 ≤ N ≤ 500)이 주어진다.,"첫째 줄에 입력으로 주어진 행렬을 곱하는데 필요한 곱셈 연산의 최솟값을 출력한다. 정답은 231-1 보다 작거나 같은 자연수이다. 또한, 최악의 순서로 연산해도 연산 횟수가 231-1보다 작거나 같다.","[['3\n5 3\n3 2\n2 6', '90']]","#include <stdio.h>
#include <limits.h> // INT_MAX 사용을 위해

#define MAX_N 500
#define INF INT_MAX // 최댓값으로 INF를 정의

int N;
int matrix[MAX_N+1][2]; // 행렬의 크기를 저장하는 배열
int dp[MAX_N+1][MAX_N+1]; // dp 테이블

int min(int a, int b) {
    return (a < b) ? a : b;
}

int main() {
    scanf(""%d"", &N);
    for (int i = 1; i <= N; i++) {
        scanf(""%d %d"", &matrix[i][0], &matrix[i][1]);
    }

    // dp 테이블 초기화
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            if (i == j) {
                dp[i][j] = 0;
            }
            else {
                dp[i][j] = INF;
            }
        }
    }

    // dp 테이블 채우기
    for (int len = 1; len < N; len++) {
        for (int i = 1; i <= N - len; i++) {
            int j = i + len;
            for (int k = i; k < j; k++) {
                int cost = dp[i][k] + dp[k+1][j] + matrix[i][0] * matrix[k][1] * matrix[j][1];
                dp[i][j] = min(dp[i][j], cost);
            }
        }
    }

    printf(""%d"", dp[1][N]);
    return 0;
}","[['2\n100 50\n50 20', '100000'], ['3\n5 3\n3 2\n2 6', '90'], ['3\n1 100\n100 1\n1 100', '200'], ['2\n20 30\n30 40', '24000'], ['3\n1000 1\n1 1000\n1000 1', '2000'], ['1\n10 10', '0'], ['2\n4 5\n5 3', '60'], ['4\n1 2\n2 3\n3 4\n4 5', '38'], ['1\n5 5\n', '0'], ['3\n5 3\n3 2\n2 6\n', '90']]"
27,29,동적 계획법 2,3,내리막 길,1520,"여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.","첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.",첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.,"[['4 5\n50 45 37 32 30\n35 50 40 20 25\n30 30 25 17 28\n27 24 22 15 10', '3']]","#include <stdio.h>

int m, n;
int map[501][501];
long long dp[501][501];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

long long dfs(int x, int y) {
    if (dp[x][y] != -1) return dp[x][y]; // 이미 방문한 곳이면 계산된 값을 반환
    dp[x][y] = 0;

    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i]; // 다음 이동할 x 좌표
        int ny = y + dy[i]; // 다음 이동할 y 좌표

        if (nx >= 0 && nx < m && ny >= 0 && ny < n) { // 범위 내에 있을 때
            if (map[nx][ny] < map[x][y]) // 이동할 수 있는 경우
                dp[x][y] += dfs(nx, ny); // 다음 좌표에서부터 계산
        }
    }

    return dp[x][y];
}

int main() {
    scanf(""%d %d"", &m, &n);

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &map[i][j]);
            dp[i][j] = -1; // dp 배열을 -1로 초기화
            // -1인 경우는 방문하지 않은 곳을 의미
        }
    }

    dp[m - 1][n - 1] = 1; // 도착점은 1가지 방법으로 갈 수 있음
    printf(""%lld"", dfs(0, 0)); // 출발점에서부터 계산

    return 0;
}","[['1 1\n1', '1'], ['3 3\n9 8 7\n6 5 4\n3 2 1', '6'], ['2 2\n1 2\n2 1', '0'], ['4 5\n50 45 37 32 30\n35 50 40 20 25\n30 30 25 17 28\n27 24 22 15 10', '3'], ['1 2\n10000 1', '1'], ['3 3\n1 5 1\n2 1 2\n1 2 1', '0'], ['4 5\n4 2 3 4 5\n1 2 3 4 5\n3 2 1 2 3\n6 5 4 3 2', '0'], ['1 1\n5', '1'], ['2 2\n1 1\n1 1', '0'], ['2 2\n1 2\n1 2', '0']]"
28,17,조합론,4,이항 계수 1,11050,"자연수
N
\(N\)과 정수
K
\(K\)가 주어졌을 때 이항 계수
(
N
K
)
\(\binom{N}{K}\)를 구하는 프로그램을 작성하시오.","첫째 줄에
N
\(N\)과
K
\(K\)가 주어진다. (1 ≤
N
\(N\) ≤ 10, 0 ≤
K
\(K\) ≤
N
\(N\))"," (
N
K
)
\(\binom{N}{K}\)를 출력한다.","[['5 2', '10']]","#include <stdio.h>

int main() {
    int n, k, i, j;
    int bin_coef[11][11] = {0}; // 이항 계수 저장 배열

    scanf(""%d %d"", &n, &k);

    // 이항 계수 구하기
    for (i = 0; i <= n; i++) {
        bin_coef[i][0] = 1; // nC0 = 1
        bin_coef[i][i] = 1; // nCn = 1
    }
    for (i = 2; i <= n; i++) {
        for (j = 1; j < i; j++) {
            bin_coef[i][j] = bin_coef[i - 1][j - 1] + bin_coef[i - 1][j]; // 파스칼의 삼각형 이용
        }
    }

    printf(""%d\n"", bin_coef[n][k]);

    return 0;
}","[['5 0', '1'], ['6 5', '6'], ['8 3', '56'], ['10 0', '1'], ['7 1', '7'], ['4 4', '1'], ['10 5', '252'], ['3 2', '3'], ['9 4', '126'], ['3 0', '1']]"
30,10,기하: 직사각형과 삼각형,1,직사각형,27323,"정수 A, B 가 주어진다. 세로 길이가 A cm, 가로 길이가 B cm 인 아래와 같은 직사각형의 넓이를 cm2 단위로 구하시오.",표준 입력에 다음과 같은 형태로 입력이 주어진다.,"세로 길이가 A cm, 가로 길이가 B cm인 직사각형의 넓이를 cm2 단위로 구하고, 단위 (cm2)를 생략하여 출력한다.","[['2\n3', '6'], ['100\n1', '100'], ['4\n4', '16']]","#include <stdio.h>

int main() {
    int a, b, area;
    scanf(""%d %d"", &a, &b);
    area = a * b;
    printf(""%d"", area);
    return 0;
}","[['1\n100', '100'], ['6\n10', '60'], ['8\n8', '64'], ['13\n15', '195'], ['3\n20', '60'], ['7\n6', '42'], ['2\n2', '4'], ['5\n7', '35'], ['12\n4', '48'], ['17\n5', '85']]"
31,10,기하: 직사각형과 삼각형,2,직사각형에서 탈출,1085,"한수는 지금 (x, y)에 있다. 직사각형은 각 변이 좌표축에 평행하고, 왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다. 직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.","첫째 줄에 x, y, w, h가 주어진다.",첫째 줄에 문제의 정답을 출력한다.,"[['6 2 10 3', '1'], ['1 1 5 5', '1'], ['653 375 1000 1000', '347'], ['161 181 762 375', '161']]","#include <stdio.h>

int main() {
    int x, y, w, h;
    scanf(""%d %d %d %d"", &x, &y, &w, &h);
    int min_distance = w - x > h - y ? h - y : w - x;
    min_distance = min_distance > x ? x : min_distance;
    min_distance = min_distance > y ? y : min_distance;
    printf(""%d\n"", min_distance);
    return 0;
}","[['8 8 10 10', '2'], ['28 982 1000 1000', '18'], ['333 111 888 999', '111'], ['1 1 1000 1000', '1'], ['0 0 2 3', '0'], ['100 100 999 999', '100'], ['50 50 900 900', '50'], ['3 3 4 5', '1'], ['3 5 5 6', '1'], ['10 20 30 40', '10']]"
32,10,기하: 직사각형과 삼각형,3,네 번째 점,3009,"세 점이 주어졌을 때, 축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.","세 점의 좌표가 한 줄에 하나씩 주어진다. 좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.",직사각형의 네 번째 점의 좌표를 출력한다.,"[['5 5\n5 7\n7 5', '7 7'], ['30 20\n10 10\n10 20', '30 10']]","#include <stdio.h>

int main() {
    int x[3], y[3];
    for (int i = 0; i < 3; i++) {
        scanf(""%d %d"", &x[i], &y[i]);
    }
    int x4 = x[0] == x[1] ? x[2] : (x[0] == x[2] ? x[1] : x[0]);
    int y4 = y[0] == y[1] ? y[2] : (y[0] == y[2] ? y[1] : y[0]);
    printf(""%d %d"", x4, y4);
    return 0;
}","[['1 1\n1 2\n2 1', '2 2'], ['10 10\n10 20\n20 10', '20 20'], ['1000 1\n1 1000\n1000 1000', '1 1'], ['50 60\n50 80\n30 60', '30 80'], ['1 1\n1 3\n3 1', '3 3'], ['90 100\n90 110\n100 100', '100 110'], ['5 5\n5 7\n7 5', '7 7'], ['30 20\n10 10\n10 20', '30 10'], ['10 10\n20 20\n10 20', '20 10'], ['7 7\n7 9\n9 7', '9 9']]"
33,10,기하: 직사각형과 삼각형,5,대지,9063," 임씨는 1950 년 한국전쟁으로 많은 손해를 본 사람들 중 하나다. 전쟁 통에 손해보지 않은 사람이 어디 있을까 만은 그는 6.25 가 일어나기 전만 해도 충청도 지방에 넓은 대지를 소유한 큰 부자였다. 전쟁이 나자 임씨는 땅문서와 값 나가는 것들만 챙겨서 일본으로 피난을 가지만 피난 중에 그만 땅문서를 잃어버리고 만다. 전쟁이 끝난 후에 임씨의 땅은 이미 다른 사람들의 논밭이 되어 있었고, 임씨는 땅을 되찾으려 했지만 문서가 없으니 생떼 쓰는 것과 다를 바 없었다. 이러다가 임씨는 길바닥에 나앉게 생겼다.","첫째 줄에는 점의 개수 N (1 ≤ N ≤ 100,000) 이 주어진다. 이어지는 N 줄에는 각 점의 좌표가 두 개의 정수로 한 줄에 하나씩 주어진다. 각각의 좌표는 -10,000 이상 10,000 이하의 정수이다. ",첫째 줄에 N 개의 점을 둘러싸는 최소 크기의 직사각형의 넓이를 출력하시오. ,"[['3\n20 24\n40 21\n10 12', '360'], ['1\n15 13', '0'], ['4\n2 1\n3 2\n5 2\n3 4', '9']]","#include <stdio.h>
#include <limits.h>

int main() {
    int n, x, y, min_x = INT_MAX, min_y = INT_MAX, max_x = INT_MIN, max_y = INT_MIN; // x, y 좌표의 최솟값과 최댓값을 저장하기 위한 변수
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        scanf(""%d %d"", &x, &y);
        if (x < min_x) min_x = x; // x 좌표의 최솟값 찾기
        if (x > max_x) max_x = x; // x 좌표의 최댓값 찾기
        if (y < min_y) min_y = y; // y 좌표의 최솟값 찾기
        if (y > max_y) max_y = y; // y 좌표의 최댓값 찾기
    }
    int width = max_x - min_x; // 가로 길이
    int height = max_y - min_y ; // 세로 길이
    printf(""%d"", width * height); // 직사각형의 넓이 출력
    return 0;
}","[['2\n-10000 -10000\n10000 10000', '400000000'], ['6\n2 2\n0 3\n-1 2\n0 0\n2 3\n1 4', '12'], ['3\n-10000 -10000\n10000 10000\n0 0', '400000000'], ['4\n0 0\n2 2\n0 2\n2 0', '4'], ['1\n0 0', '0'], ['2\n10000 -10000\n-10000 10000', '400000000'], ['3\n4 1\n0 0\n5 -4', '25'], ['3\n0 4\n4 4\n2 0', '16'], ['6\n0 0\n1 1\n2 2\n-1 -1\n10 10\n-10 -10', '400'], ['4\n0 0\n0 1\n1 1\n1 0', '1']]"
34,10,기하: 직사각형과 삼각형,6,삼각형 외우기,10101,창영이는 삼각형의 종류를 잘 구분하지 못한다. 따라서 프로그램을 이용해 이를 외우려고 한다.,"총 3개의 줄에 걸쳐 삼각형의 각의 크기가 주어진다. 모든 정수는 0보다 크고, 180보다 작다.","문제의 설명에 따라 Equilateral, Isosceles, Scalene, Error 중 하나를 출력한다.","[['60\n70\n50', 'Scalene']]","#include <stdio.h>

int main() {
    int a, b, c;
    scanf(""%d %d %d"", &a, &b, &c);

    if (a + b + c != 180) {
        printf(""Error\n"");
    } else if (a == b && b == c) {
        printf(""Equilateral\n"");
    } else if (a == b || b == c || c == a) {
        printf(""Isosceles\n"");
    } else {
        printf(""Scalene\n"");
    }

    return 0;
}","[['60\n70\n50', 'Scalene'], ['60\n60\n60', 'Equilateral'], ['30\n60\n90', 'Scalene'], ['60\n60\n130', 'Error'], ['70\n70\n40', 'Isosceles'], ['100\n30\n50', 'Scalene'], ['90\n45\n45', 'Isosceles'], ['40\n80\n60', 'Scalene'], ['80\n70\n30', 'Scalene'], ['80\n50\n50', 'Isosceles']]"
35,12,브루트 포스,4,체스판 다시 칠하기,1018,"지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.","첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.",첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.,"[['8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW', '1'], ['10 13\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nWWWWWWWWWWBWB\nWWWWWWWWWWBWB', '12'], ['8 8\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB', '0'], ['9 23\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBW', '31'], ['10 10\nBBBBBBBBBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBBBBBBBBB', '0'], ['8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWWWB\nBWBWBWBW', '2'], ['11 12\nBWWBWWBWWBWW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBWWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW', '15']]","#include <stdio.h>
#define MAX_N 50
#define MAX_M 50

int N, M;
char board[MAX_N][MAX_M+1]; // 보드 상태를 저장하는 2차원 배열

int paint(int x, int y) { // (x, y)를 왼쪽 위 모서리로 하는 8x8 체스판을 다시 칠해야하는 최소 개수 반환
    int cnt1 = 0, cnt2 = 0; // cnt1: 왼쪽 위 모서리가 W인 경우 칠하는 최소 개수, cnt2: 왼쪽 위 모서리가 B인 경우 칠하는 최소 개수
    for (int i = x; i < x + 8; i++) {
        for (int j = y; j < y + 8; j++) {
            if ((i + j) % 2 == 0) { // (i, j)가 흰색이어야 하는 경우
                if (board[i][j] == 'B') cnt1++;
                else cnt2++;
            } else { // (i, j)가 검은색이어야 하는 경우
                if (board[i][j] == 'W') cnt1++;
                else cnt2++;
            }
        }
    }
    return cnt1 < cnt2 ? cnt1 : cnt2; // 더 적게 칠하는 최소 개수 반환
}

int main() {
    scanf(""%d %d"", &N, &M);
    for (int i = 0; i < N; i++) {
        scanf(""%s"", board[i]);
    }

    int min_cnt = N*M; // 모든 칸을 다시 칠해야하는 경우가 최악의 경우이므로, 최대값으로 초기화
    for (int i = 0; i <= N-8; i++) {
        for (int j = 0; j <= M-8; j++) {
            int cnt = paint(i, j); // (i, j)를 왼쪽 위 모서리로 하는 8x8 체스판을 다시 칠해야하는 최소 개수
            if (cnt < min_cnt) min_cnt = cnt;
        }
    }

    printf(""%d\n"", min_cnt); // 최소값 출력

    return 0;
}","[['9 9\nWBWBWBWBW\nBWBWBWBWB\nWBWBWBWBW\nBWBWBWBWB\nWBWBWBWBW\nBWBWBWBWB\nWBWBWBWBW\nBWBWBWBWB\nWBWBWBWBW', '0'], ['8 8\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB', '32'], ['8 8\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBBBBBBBB\nBWWWWWWW\nBWWWWWWW\nBWWWWWWW\nBWWWWWWW', '32'], ['50 50\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\nB\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWB', '0'], ['12 12\nBBBBBBBBBBBB\nBBWBBBBBBBWB\nBBWBBBBWBBBB\nBBWBBBWBWBBB\nBWWBBWBBBWBB\nBWBWBBBBWBBB\nBWWBBBBWBWBB\nBWBWBWBBBBWB\nBWBWBBBBBBBW\nBWWBWWWWWBWB\nBWBWWBWWBWBB\nBBBBBBBBBBBB', '21'], ['10 10\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW\nWWWWWWWWWW', '32'], ['50 50\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', '0'], ['10 10\nWBBBBBBBB\nBBBBBBBBW\nWBBBBBBBB\nBBBBBBBBW\nWBBBBBBBB\nBBBBBBBBW\nWBBBBBBBB\nBBBBBBBBW\nWBBBBBBBB\nBBBBBBBBW', '28'], ['8 8\nWWBBWWBW\nBWBWWBWB\nWWBWWBWB\nBBWWBWBW\nWBBWBBWW\nBWBWBWBW\nWBBWBWBW\nBWBWBWBB', '25'], ['15 50\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\nBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', '24']]"
36,12,브루트 포스,5,영화감독 숌,1436,"666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.","첫째 줄에 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.",첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.,"[['2', '1666'], ['3', '2666'], ['6', '5666'], ['187', '66666'], ['500', '166699']]","#include <stdio.h>

int main() {
    int n, cnt = 0, num = 665; // num 초기값은 665
    scanf(""%d"", &n);

    while(cnt < n) {
        num++; // 1씩 증가시키며
        int temp = num; // temp에 복사
        while(temp >= 666) { // 666 이상이라면
            if(temp % 1000 == 666) { // 뒤 3자리 확인
                cnt++; // 666이 있다면 cnt 증가
                break;
            }
            temp /= 10; // 한 자리씩 앞으로 이동
        }
    }

    printf(""%d"", num);
    return 0;
}","[['1', '666'], ['8', '6661'], ['13', '6666'], ['16', '6669'], ['42', '23666'], ['100', '54666'], ['234', '76664'], ['888', '326663'], ['999', '366638'], ['1000', '366639']]"
37,12,브루트 포스,6,설탕 배달,2839,상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.,첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000),"상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.","[['18', '4'], ['4', '-1'], ['6', '2'], ['9', '3'], ['11', '3']]","#include <stdio.h>

int main() {
    int n;
    scanf(""%d"", &n);

    int count = -1;
    for (int i = n / 5; i >= 0; i--) {
        if ((n - (i * 5)) % 3 == 0) {
            count = i + (n - (i * 5)) / 3;
            break;
        }
    }

    printf(""%d\n"", count);

    return 0;
}","[['3', '1'], ['8', '2'], ['10', '2'], ['15', '3'], ['16', '4'], ['19', '5'], ['30', '6'], ['4', '-1'], ['5', '1'], ['6', '2']]"
38,13,정렬,1,수 정렬하기,2750,"N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.","첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.",첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.,"[['5\n5\n2\n3\n4\n1', '1\n2\n3\n4\n5']]","#include <stdio.h>
#include <stdlib.h>

int compare(const void* a, const void* b) { // 오름차순 비교 함수
    if (*(int*)a > *(int*)b) return 1;
    else if (*(int*)a < *(int*)b) return -1;
    else return 0;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]); // 수 입력받음
    }

    qsort(arr, n, sizeof(int), compare); // 퀵 정렬 함수를 이용하여 오름차순으로 정렬

    for (int i = 0; i < n; i++) {
        printf(""%d\n"", arr[i]); // 정렬된 수 출력
    }

    return 0;
}","[['3\n2\n1\n3', '1\n2\n3'], ['5\n5\n4\n3\n2\n1', '1\n2\n3\n4\n5'], ['4\n4\n3\n2\n1', '1\n2\n3\n4'], ['6\n5\n1\n3\n4\n2\n6', '1\n2\n3\n4\n5\n6'], ['2\n1\n-1', '-1\n1'], ['7\n7\n6\n5\n4\n3\n2\n1', '1\n2\n3\n4\n5\n6\n7'], ['10\n1\n4\n6\n9\n3\n2\n5\n7\n8\n10', '1\n2\n3\n4\n5\n6\n7\n8\n9\n10'], ['3\n-1\n0\n1', '-1\n0\n1'], ['8\n1\n4\n7\n6\n3\n5\n2\n8', '1\n2\n3\n4\n5\n6\n7\n8'], ['1\n1', '1']]"
39,13,정렬,3,커트라인,25305,"2022 연세대학교 미래캠퍼스 슬기로운 코딩생활에
N
$N$명의 학생들이 응시했다.","첫째 줄에는 응시자의 수
N
$N$과 상을 받는 사람의 수
k
$k$가 공백을 사이에 두고 주어진다.",상을 받는 커트라인을 출력하라.,"[['5 2\n100 76 85 93 98', '98']]","#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return *(int*)b - *(int*)a;
}

int main() {
    int n, k;
    scanf(""%d %d"", &n, &k);

    int scores[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &scores[i]);
    }

    qsort(scores, n, sizeof(int), cmp);

    printf(""%d"", scores[k-1]);

    return 0;
}","[['7 3\n20 30 40 50 60 70 80', '60'], ['5 1\n90 70 80 60 75', '90'], ['3 1\n50 30 40', '50'], ['7 1\n60 70 80 90 100 110 120', '120'], ['4 1\n3 2 1 4', '4'], ['2 1\n50 40', '50'], ['3 1\n50 60 70', '70'], ['5 3\n50 70 80 90 60', '70'], ['7 3\n90 95 85 80 75 70 65', '85'], ['1 1\n84', '84']]"
40,13,정렬,6,소트인사이드,1427,"배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.","첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.",첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.,"[['2143', '4321'], ['999998999', '999999998'], ['61423', '64321'], ['500613009', '965310000']]","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int desc(const void *a, const void *b) {
    return *(char*)b - *(char*)a; // 내림차순 정렬을 위한 비교 함수
}

int main() {
    char str[11]; // 정렬할 수를 문자열로 입력 받음
    scanf(""%s"", str);

    int len = strlen(str);
    qsort(str, len, sizeof(char), desc); // qsort 함수를 이용한 내림차순 정렬

    printf(""%s\n"", str);

    return 0;
}","[['1', '1'], ['10', '10'], ['1234', '4321'], ['111111111', '111111111'], ['369258', '986532'], ['9876543210', '9876543210'], ['111222333\n', '333222111'], ['36900123\n', '96332100'], ['52555\n', '55552'], ['8\n', '8']]"
41,14,집합과 맵,7,대칭 차집합,1269,"자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다.","첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다.",첫째 줄에 대칭 차집합의 원소의 개수를 출력한다.,"[['3 5\n1 2 4\n2 3 4 5 6', '4']]","#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return *(int*)a - *(int*)b;
}

int main() {
    int n, m;
    scanf(""%d %d"", &n, &m);
    int a[n], b[m];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &a[i]);
    }
    for (int i = 0; i < m; i++) {
        scanf(""%d"", &b[i]);
    }
    qsort(a, n, sizeof(int), cmp);
    qsort(b, m, sizeof(int), cmp);
    int cnt = 0;
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (a[i] == b[j]) {
            i++;
            j++;
        }
        else if (a[i] > b[j]) {
            j++;
            cnt++;
        }
        else {
            i++;
            cnt++;
        }
    }
    cnt += n - i + m - j; // 남은 숫자들이 대칭 차집합 원소임
    printf(""%d"", cnt);
    return 0;
}","[['1 1\n1\n2', '2'], ['3 5\n1 2 4\n2 3 4 5 6', '4'], ['4 3\n10 20 30 40\n50 60 70', '7'], ['5 5\n1 3 5 7 9\n2 4 6 8 10', '10'], ['10 10\n1 2 3 4 5 6 7 8 9 10\n1 2 3 4 5 6 7 8 9 10', '0'], ['10 10\n1 4 6 7 10 12 13 14 15 17\n2 3 5 7 8 9 11 13 15 18', '14'], ['5 5\n5 10 20 40 50\n5 10 20 30 40', '2'], ['3 3\n1 3 5\n2 4 6', '6'], ['5 5\n1 2 3 4 5\n6 7 8 9 10', '10'], ['5 3\n1 5 6 7 8\n2 6 8', '4']]"
42,15,"약수, 배수와 소수 2",1,최소공배수,1934,"두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다. 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다. 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.","첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)",첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.,"[['3\n1 45000\n6 10\n13 17', '45000\n30\n221']]","#include <stdio.h>

int gcd(int a, int b) { // 최대공약수 함수
    if (a % b == 0) {
        return b;
    }
    return gcd(b, a % b);
}

int lcm(int a, int b) { // 최소공배수 함수
    return a * b / gcd(a, b);
}

int main() {
    int T;
    scanf(""%d"", &T);

    for (int i = 0; i < T; i++) {
        int A, B;
        scanf(""%d %d"", &A, &B);
        printf(""%d\n"", lcm(A, B));
    }

    return 0;
}","[['1\n1 1000', '1000'], ['1\n45000 1', '45000'], ['1\n12 36', '36'], ['1\n37 44', '1628'], ['1\n13 23', '299'], ['1\n38 47', '1786'], ['1\n40 40', '40'], ['1\n999 1000', '999000'], ['1\n2 17', '34'], ['1\n450 900', '900']]"
43,15,"약수, 배수와 소수 2",3,분수 합,1735,"분수 A/B는 분자가 A, 분모가 B인 분수를 의미한다. A와 B는 모두 자연수라고 하자.","첫째 줄과 둘째 줄에, 각 분수의 분자와 분모를 뜻하는 두 개의 자연수가 순서대로 주어진다. 입력되는 네 자연수는 모두 30,000 이하이다.",첫째 줄에 구하고자 하는 기약분수의 분자와 분모를 뜻하는 두 개의 자연수를 빈 칸을 사이에 두고 순서대로 출력한다.,"[['2 7\n3 5', '31 35']]","#include <stdio.h>

int gcd(int a, int b) { // 최대공약수
    while (b != 0) {
        int r = a % b;
        a = b;
        b = r;
    }
    return a;
}

int main() {
    int a1, b1, a2, b2;
    scanf(""%d %d %d %d"", &a1, &b1, &a2, &b2);

    int numerator = (a1 * b2) + (a2 * b1); // 분자
    int denominator = b1 * b2; // 분모

    int g = gcd(numerator, denominator); // 최대공약수 구하기
    numerator /= g;
    denominator /= g;

    printf(""%d %d"", numerator, denominator);
    return 0;
}","[['1 1\n1 1', '2 1'], ['99 100\n1 1', '199 100'], ['1 100\n1 1', '101 100'], ['3 4\n2 5', '23 20'], ['1 1\n3 1', '4 1'], ['1 2\n1 3', '5 6'], ['3 4\n5 6', '19 12'], ['1 3\n2 5', '11 15'], ['20 14\n10 21', '40 21'], ['3 7\n2 5', '29 35']]"
44,15,"약수, 배수와 소수 2",6,소수 구하기,1929,M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.,"첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.","한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.","[['3 16', '3\n5\n7\n11\n13']]","#include <stdio.h>

int main() {
    int m, n;
    scanf(""%d %d"", &m, &n);

    // 에라토스테네스의 체 알고리즘을 이용하여 소수를 구함
    int arr[1000001] = {0,}; // 1~1000000사이의 숫자들이 소수인지 아닌지를 판별하는 배열
    for(int i=2; i<=n; i++) {
        if(arr[i] == 0) { // 아직 소수가 아니라고 판별되지 않았다면
            if(i >= m) printf(""%d\n"", i); // M 이상의 소수이면 출력
            for(int j=i*2; j<=n; j+=i) { // i의 배수인 숫자들은 소수가 아님
                arr[j] = 1;
            }
        }
    }

    return 0;
}","[['2 2', '2'], ['3 3', '3'], ['1 100', '2\n3\n5\n7\n11\n13\n17\n19\n23\n29\n31\n37\n41\n43\n47\n53\n59\n61\n67\n71\n73\n79\n83\n89\n97'], ['500 550', '503\n509\n521\n523\n541\n547'], ['1 10', '2\n3\n5\n7'], ['1 2', '2'], ['1 5', '2\n3\n5'], ['100 200', '101\n103\n107\n109\n113\n127\n131\n137\n139\n149\n151\n157\n163\n167\n173\n179\n181\n191\n193\n197\n199'], ['1 3', '2\n3'], ['5 5', '5']]"
